Practical-9
-----------
- Write a procedure to update, delete and insert new element in nested table.


-- Step 1: Object type
CREATE OR REPLACE TYPE address_rec AS OBJECT (
    block    VARCHAR2(50),
    block_no VARCHAR2(10),
    area     VARCHAR2(100),
    pincode  NUMBER
);
/ 

-- Step 2: Nested table type
CREATE OR REPLACE TYPE address_tbl AS TABLE OF address_rec;
/

-- Step 3: Table with nested table column
CREATE TABLE TEACHER (
    teacher_id   NUMBER PRIMARY KEY,
    teacher_name VARCHAR2(100),
    addresses    address_tbl
) 
NESTED TABLE addresses STORE AS addresses_nt
STORAGE (
    INITIAL 1000        
    NEXT 100           
    MINEXTENTS 1       
    MAXEXTENTS 2 
);

-- Step 4: Sample data
INSERT INTO TEACHER (teacher_id, teacher_name, addresses)
VALUES (1, 'jaydip', address_tbl(
        address_rec('Block A', '1', 'Gota', 382481),
        address_rec('Block B', '2', 'Vandematram', 382481)
    ));

INSERT INTO TEACHER (teacher_id, teacher_name, addresses)
VALUES (2, 'harsh', address_tbl(
        address_rec('Block C', '3', 'Vaishnov devi', 382421)
    ));

COMMIT;

-- Step 5: Procedure without sparse delete
CREATE OR REPLACE PROCEDURE manage_teacher_address (
    p_teacher_id IN NUMBER,
    p_action     IN VARCHAR2,
    p_index      IN INTEGER DEFAULT NULL,
    p_block      IN VARCHAR2 DEFAULT NULL,
    p_block_no   IN VARCHAR2 DEFAULT NULL,
    p_area       IN VARCHAR2 DEFAULT NULL,
    p_pincode    IN NUMBER   DEFAULT NULL
) AS
    v_addresses address_tbl;  
    v_new_addresses address_tbl := address_tbl();  -- fresh collection for delete
BEGIN
    -- Fetch current addresses
    SELECT addresses INTO v_addresses 
    FROM TEACHER 
    WHERE teacher_id = p_teacher_id;

    -- INSERT new address
    IF UPPER(p_action) = 'INSERT' THEN
        v_addresses.EXTEND;
        v_addresses(v_addresses.COUNT) := address_rec(p_block, p_block_no, p_area, p_pincode);
        DBMS_OUTPUT.PUT_LINE('Address inserted.');

    -- UPDATE address at given index
    ELSIF UPPER(p_action) = 'UPDATE' THEN
        IF p_index IS NOT NULL AND p_index BETWEEN 1 AND v_addresses.COUNT THEN
            v_addresses(p_index) := address_rec(p_block, p_block_no, p_area, p_pincode);
            DBMS_OUTPUT.PUT_LINE('Address updated.');
        ELSE
            DBMS_OUTPUT.PUT_LINE('Invalid index for update.');
        END IF;

    -- DELETE without leaving gaps
    ELSIF UPPER(p_action) = 'DELETE' THEN
        IF p_index IS NOT NULL AND p_index BETWEEN 1 AND v_addresses.COUNT THEN
            FOR i IN 1..v_addresses.COUNT LOOP
                IF i != p_index THEN
                    v_new_addresses.EXTEND;
                    v_new_addresses(v_new_addresses.COUNT) := v_addresses(i);
                END IF;
            END LOOP;
            v_addresses := v_new_addresses; -- replace with compact version
            DBMS_OUTPUT.PUT_LINE('Address deleted.');
        ELSE
            DBMS_OUTPUT.PUT_LINE('Invalid index for deletion.');
        END IF;

    ELSE
        DBMS_OUTPUT.PUT_LINE('Invalid action. Use INSERT, UPDATE, or DELETE.');
    END IF;

    -- Save back changes
    UPDATE TEACHER
    SET addresses = v_addresses
    WHERE teacher_id = p_teacher_id;
END;
/


-- Update 1st address of teacher 1
EXEC manage_teacher_address(1, 'UPDATE', 1, 'Block D', '1A', 'Nikol', 382401);

-- Insert new address
EXEC manage_teacher_address(1, 'INSERT', NULL, 'Block K', '4', 'Narol', 382142);

-- Delete 1st address of teacher 2 (without leaving gap)
EXEC manage_teacher_address(2, 'DELETE', 1);



SELECT teacher_id, teacher_name, t.addresses
FROM TEACHER t;

SELECT t.teacher_id, t.teacher_name, a.*
FROM TEACHER t, TABLE(t.addresses) a;

